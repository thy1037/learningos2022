# LAB2 实验报告
*2022-7-20*

## 简述功能
在引入页表机制，实现虚拟地址后，首先重现实现了 LAB1 的功能：获取时间和获取任务信息。之后增加了 `mmap` 和 `munmap` 两个系统调用用于申请和释放内存。

## 简答题
1. SV39 页表项组成：

| 域 | 名称 | 作用 |
|--- | --- | --- |
| bit 0 | V | 仅当该位为 1 时，页表项有效 |
| bit 1 | R | 读允许 |
| bit 2 | W | 写允许 |
| bit 3 | X | 取指允许（执行） |
| bit 4 | U | U 态下是否允许访问 |
| bit 5 | G | 忽略 |
| bit 6 | A | 记录该位清零后，对应的虚拟页面是否被访问过（读） |
| bit 7 | D | 记录该位清零后，对应的虚拟页面是否被修改过（写） |
| bit 8~9 | RSW | 忽略 |
| bit 10~53 | PPN[0～2] | 44位的物理页号 |
| bit 54~63 | Reserved | 保留 |

2. 缺页
    1. `mcause` 寄存器会保存发生中断异常的原因，其中 `Exception Code` 为 12 表示指令缺页异常，13 表示 Load 异常，15 表示 Store/AMO 缺页异常，
    2. 发生异常时寄存器描述
        * scause：`interrupt` 记录中断还是异常， `Exception Code` 记录中断/异常的种类
        * sstatus：记录当前状态，`SPP` 记录当前特权等级
        * stvec：记录处理 trap 的入口地址
        * sscratch：其中的值是指向 Hart 相关的 S 态上下文的指针，如内核栈顶地址
        * sepc：trap 发生时的下一条指令地址
        * stval：trap 发生进入 S 态时会将异常信息写入，用于帮助处理 trap，其中会保存缺页异常的虚拟地址
    3. 优点1：加快程序启动速度；优点2：避免内存重复加载，在启动时就将所有内容加载到内存，如果没有及时执行，有可能会因为内存不足而被覆盖，执行时需要重新加载
    4. 大约占用 20M = 10G / 512M 内存
    5. `Page Fault` 服务函数首先判断该数据的虚拟地址是否是该任务的合法地址；然后取出保存在对应页表项中的扇区地址，将在该扇区数据；更新页表项内容，将页表项中的存在位置 1；最后返回任务，让该任务重新执行访问数据的指令。
    6. 页表项 `V` 标志位置 0

3. 双页表与单页表
    1. 通过多级页表更换页表
    2. 页表项 `U` 标志位置 0
    3. 内核态和用户态切换时不需要更换页表，也就不需要跳板
    4. 双页表实现下用户程序和内核转换时、用户程序转换时都需要更换页表，而对于单页表实现，不同用户线程切换时需要更换页表

## 完成记录
1. 在引入业表机制，实现虚拟地址后,用户程序只能接收到虚拟地址，实现 `mm::get_refmut`,虚拟地址到物理地址的转换
2. 重新实现系统调用计数的实现，注意这一次需要加入程序开始运行的时间的，而不是简单的从0开始
3. 在 `TaskManager` 中实现 `mmap` 和 `munmap`
4. `mmap` 需要注意检查起始地址对齐问题，对应地址是否有效，插入页表项后检查是否成功，
5. `munmap` 需要注意待释放区域是否有效，释放后检查是否还在页表项内

**过程中参考了 Yakkhini 同学的代码，无法独立完成，后续需要强化该章知识。**
